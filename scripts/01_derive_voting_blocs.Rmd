---
title: "MSc-ESC"
output: 
  html_document:
    toc: true
    df_print: kable
---

# Section 1 - Derviving Voting Blocs

This section generates historical voting blocs from Eurovision voting data. The social network methods used to identify the voting blocs are cited from multiple academic papers. The voting blocs can be used as independent variables to explain contest scores. The countries will be clustered together into voting blocs using the average vote score. The connectedness of the clusters / communities will be evaluated using modularity. The modularity of a graph with respect to some division (or vertex types) measures how good the grouping is. The higher the modularity the greater the division between communities and the better grouping

```{r preliminaries, message=FALSE}
# Load in relevant libraries
library(rmarkdown)
library(knitr)
library(igraph)
library(dplyr)

# load in the historic voting data for deriving the voting blocs
past_voting_data <- read.csv(file = "./data/ESC_hist_voting_data.csv", header = T)
```

## Data Profiling

```{r data-profiling}
# the head of the data
head(past_voting_data)
# structure of the data
str(past_voting_data)
# summary statistics of the data
summary(past_voting_data)
# there is no missing data
anyNA(past_voting_data)
```

## Construct the average vote matrix

```{r average-vote-matrix, message=FALSE}
# Average over the voting data
pvd <- past_voting_data %>% 
       select(From.country, To.country, Points) %>%
       group_by(From.country, To.country) %>%
       summarise(Average.Points = mean(Points)) %>%
       as.data.frame()

# write the average voting data to a csv file
write.csv(x = pvd, file = "./data/average_points.csv", row.names = F)
```

## Construct the Average Points Graph

```{r average-point-graph}
# graph the data based on the weight of the average point score
# assumption: an average point score of 8 or more is a sign of bloc voting
G <- graph_from_data_frame(d = pvd[pvd$Average.Points >= 8, 1:2], directed = T)
E(G)$weight <- as.numeric(pvd[pvd$Average.Points >= 8, 3])
# check the graph is weighted
if (is_weighted(G) == FALSE){
  stop("Voting Network Graph is Unweighted.")
}
```

## Derive the Voting Blocs

Edge Betweeness Clustering

```{r edge-between-clustering, warning=FALSE}
# Extract the voting blocs
# 21 groups
# global modularity = 0.057
# Perform Edge between clustering
com1 <- cluster_edge_betweenness(graph = G, weights = E(G)$weight)
# calculate modularity of the graph
modularity(com1)
# get the number of groups
max(com1$membership)
# create a data frame out of the clustering results
com1df <- rbind(com1$names, com1$membership)
# assign the row names to the data frame
row.names(com1df) <- c("Country", "Group")
# show head of results
t(head(com1df))
# construct a dendrogram (hierarchical clustering method)
plot_dendrogram(com1, main = "Dendrogram of EDge Betweeness Clustering")
```

Short Random Walks

```{r short-random-walks}
# Extract voting blocs
# 6 groups
# global modularity = 0.3
# perform short random walks clustering
com2 <- cluster_walktrap(graph = G, weights = E(G)$weight)
# calculate modularity of the graph
modularity(com2)
# get the number of groups
max(com2$membership)
# create a data frame out of the clustering results
com2df <- rbind(com2$names, com2$membership)
# assign the row names to the data frame
row.names(com2df) <- c("Country", "Group")
# show head of results
t(head(com2df))
# construct a dendrogram (hierarchical clustering method)
plot_dendrogram(com2, main = "Dendrogram of Short Random Walk Clustering")
```

## Construct voting blocs data frame

```{r voting-blocks-dataframe}
# UPDATE: for the propose of this research we shall only include hierarchical clustering methods
# (1) Edge-betweenness 
# (2) Short Random Walks
# combine results over both clustering methods into a data frame
voting_bloc_data <- as.data.frame(cbind(com1$names, com1$membership, com2$membership))
# assign column names to the output data frame
colnames(voting_bloc_data) <- c("Country", "VBlocs1_EB", "VBlocs2_SRW")
# show head of results
head(voting_bloc_data)
# generate summary of data
summary(voting_bloc_data)
# Writing Voting Bloc Data to csv file
write.csv(x = voting_bloc_data, file = "./data/voting_bloc_data.csv", row.names = F)
```