---
title: "Model Evaluation"
output: 
  pdf_document:
    toc: true
    toc_depth: 3
    df_print: kable
---

## Overview

This section evaluates the fit of the model's using the car package. Multiple linear regression (MLR) requires the model residuals to be ~ IID N(0, sigma^2). The model residuals will be standardized for the assessment.

1. Normality Assumptions will be accessed using:
    * Normality tests from the nortest package
    * Visualizations such as histograms, QQ-plots, Residual Plots and Add Variable Plots
2. Constant Variance will be accessed using:
    * non-constant variance test
3. Multi-collinearity will be accessed using:
    * variance inflation factors
4. Outliers will be accessed using:
    * Cooks Distance

```{r preliminaries, message = FALSE, echo = FALSE, warning = FALSE}
# load relevant libraries
library(rmarkdown)
library(knitr)
library(car)
library(MASS)
library(nortest)
library(lmtest)
library(dplyr)
# load custom functions
source('scripts/utilities/bonferroni_outlier_test.R')
source('scripts/utilities/sresid_outliers.R')
source('scripts/utilities/normality_tests.R')
source('scripts/utilities/ncv_test.R')
source('scripts/utilities/model_vifs.R')
source('scripts/utilities/boxcox_transplot.R')
source('scripts/utilities/plot_residuals_vs_fits.R')
source('scripts/utilities/plot_cooks.R')
```

```{r data-load, echo = FALSE, warning = FALSE}
# load in the historic voting data for deriving the voting blocs
processed_data <- read.csv(file = "./data/processed_data.csv", header = T)
# split the televote data
televote_data <- processed_data %>% filter(Voting_Method_J == 0)
# split out the jury vote data
jury_data <- processed_data %>% filter(Voting_Method_J == 1)
```

\newpage

## Overall Model

```{r overall-model, echo = FALSE, warning = FALSE}
# load final overall model
my_model_overall <- readRDS("./models/overall_final_model.RDS")
# extract out the model coefficients
overall_model_coeff <- names(my_model_overall$coefficients)[-1]
# recreate the model formula
overall_final_model_form<- as.formula(paste('Points ~', paste(overall_model_coeff, collapse = ' + ')))
# generate model summary
summary(my_model_overall)
```

### Transformation of Response Variable

```{r overall-box-cox, echo = FALSE, warning = FALSE}
# Apply box-cox transformation on the model to improve the normality assumptions 
# box-cox transformation using car
bct <- boxcox_transplot(my_model_overall, output_fpath = './report/plots/boxcox/model_overall_boxcox.jpg')
# find optimal box-cox power transformation power
p <- bct$x[which.max(x = bct$y)]
# transform points using the optimal power transformation
bctPoints <- (((processed_data$Points)^p) - 1)/(p)
# recreate the model formula
overall_final_model_bct_form<- as.formula(paste('bctPoints ~', paste(overall_model_coeff, collapse = ' + ')))
# refit final model with with box-cox power transformation
my_model_overall <- lm(formula = overall_final_model_bct_form, data = processed_data)
# generate model summary
summary(my_model_overall)
```

![Overall Model BoxCox Transformation](../report/plots/boxcox/model_overall_boxcox.jpg)\newline

### Evaluate the Fit of the Model

```{r overall-standardise-residuals, echo = FALSE, warning = FALSE, results = 'hide'}
# generate standardised residuals
sresid <- studres(my_model_overall)
# plot residuals vs fits model
plot_residuals_vs_fits(model = my_model_overall, main = "Overall Model - Standardised Residuals vs Fitted Values", output_fpath = './report/plots/residual/model_overall_residuals_vs_fits.jpg')
```

![Overall Model Standardised Residuals vs Fits](../report/plots/residual/model_overall_residuals_vs_fits.jpg)\newline

```{r overall-outliers, echo = FALSE, warning = FALSE}
# Assessing Outliers
# Bonferonni p-value for most extreme obs
bonferroni_outlier_test(my_model_overall)
# print example outliers
head(sresid_outliers(sresid, cutoff = -2))
# leverage plots
leveragePlots(my_model_overall, ask = FALSE) 
# Added variable Plots
avPlots(my_model_overall, ask = FALSE)
# Cook's D plot
plot_cooks(model = my_model_overall, data = processed_data, output_fpath = './report/plots/residual/model_overall_cooks.jpg')
```

![Overall Model Cooks Distance](../report/plots/residual/model_overall_cooks.jpg)\newline

```{r overall-outliers-plots, echo = FALSE, warning = FALSE, results = 'hide'}
# Residual Plots
residualPlots(my_model_overall)
# Influence Plot 
influencePlot(my_model_overall, id.method = "identify", main = "Influence Plot", sub = "Circle size is proportial to Cook's Distance" )
```

Normality Test

* Ho: The data is normally distributed
* Ha: the data is not normally distributed


```{r overall-normality-tests, echo = FALSE, warning = FALSE}
# Normality Test
normality_tests(sresid)
# the data is not normally distributed
# Histogram of residuals
hist(sresid, freq = FALSE, main = "Distribution of Standardised Residuals", ylim = c(0,0.4),  xlim = c(-4, 3))
xfit <- seq(min(sresid, na.rm = TRUE), max(sresid, na.rm = TRUE), length = 40) 
yfit <- dnorm(xfit) 
lines(xfit, yfit)
```

```{r overall-normality-tests-qqplot, echo = FALSE, warning = FALSE, results = 'hide'}
# QQ-plot of the data
qqPlot(my_model_overall, ylab = "Standardised Residuals", main = "QQ-Plot of Overall Model Standardised Residuals")
```

Non-Constant Error Variance Test

* Ho: constant error variance
* Ha: Non-constant error Variance


```{r overall-nonconstant-variance, echo = FALSE, warning = FALSE}
# Non-Constant Error Variance Test
ncv_test(my_model_overall)
```

```{r overall-nonconstant-variance-spreadlevelplot, echo = FALSE, warning = FALSE, results = 'hide'}
# plot studentized residuals vs. fitted values 
spreadLevelPlot(my_model_overall, main = "Spread-Level Plot for Overall Model")
```

```{r overall-vifs, echo = FALSE, warning = FALSE}
# Variance Inflation Factors 
model_vifs(my_model_overall)
# No signs of collinearity
```

\newpage

## Televote Model

```{r televote-model, echo = FALSE, warning = FALSE}
# load final televote model
my_model_tele <- readRDS("./models/televote_final_model.RDS")
# extract out the model coefficients
tele_model_coeff <- names(my_model_tele$coefficients)[-1]
# recreate the model formula
televote_final_model_form<- as.formula(paste('Points ~', paste(tele_model_coeff, collapse = ' + ')))
# generate model summary
summary(my_model_tele)
```

### Transformation of Response Variable

```{r televote-box-cox, echo = FALSE, warning = FALSE}
# Apply box-cox transformation on the model to improve the normality assumptions 
# box-cox transformation using car
bct <- boxcox_transplot(my_model_tele, output_fpath = './report/plots/boxcox/model_tele_boxcox.jpg')
# find optimal box-cox power transformation power
p <- bct$x[which.max(x = bct$y)]
# transform points using the optimal power transformation
bctPoints <- (((televote_data$Points)^p) - 1)/(p)
# recreate the model formula
televote_final_model_bct_form <- as.formula(paste('bctPoints ~', paste(tele_model_coeff, collapse = ' + ')))
# refit final model with with box-cox power transformation
my_model_tele <- lm(formula = televote_final_model_bct_form, data = televote_data)
# generate model summary
summary(my_model_tele)
```

![Televote Model BoxCox Transformation](../report/plots/boxcox/model_tele_boxcox.jpg)\newline

### Evaluate the Fit of the Model

```{r televote-standardise-residuals, echo = FALSE, warning = FALSE, results = 'hide'}
# generate standardised residuals
sresid <- studres(my_model_tele)
# plot residuals vs fits model
plot_residuals_vs_fits(model = my_model_tele, main = "Televote Model - Standardised Residuals vs Fitted Values", output_fpath = './report/plots/residual/model_tele_residuals_vs_fits.jpg')
```

![Televote Model Standardised Residuals vs Fits](../report/plots/residual/model_tele_residuals_vs_fits.jpg)\newline

```{r televote-outliers, echo = FALSE, warning = FALSE}
# Assessing Outliers
# Bonferonni p-value for most extreme obs
bonferroni_outlier_test(my_model_tele)
# print example outliers
head(sresid_outliers(sresid, cutoff = -2))
# leverage plots
leveragePlots(my_model_tele, ask = FALSE) 
# Added variable Plots
avPlots(my_model_tele, ask = FALSE)
# Cook's D plot
plot_cooks(model = my_model_tele, data = processed_data, output_fpath = './report/plots/residual/model_tele_cooks.jpg')
```
![Telebote Model Cooks Distance](../report/plots/residual/model_tele_cooks.jpg)\newline


```{r televote-outliers-plots, echo = FALSE, warning = FALSE, results = 'hide'}
# Residual Plots
residualPlots(my_model_tele)
# Influence Plot 
influencePlot(my_model_tele, id.method = "identify", main = "Influence Plot", sub = "Circle size is proportial to Cook's Distance" )
```

Normality Test

* Ho: The data is normally distributed
* Ha: the data is not normally distributed

```{r televote-normality-tests, echo = FALSE, warning = FALSE}
# Normality Test
normality_tests(sresid)
# the data is not normally distributed
# Histogram of residuals
hist(sresid, freq = FALSE, main = "Distribution of Studentised Residuals")
xfit <- seq(min(sresid, na.rm = TRUE), max(sresid, na.rm = TRUE), length = 40) 
yfit <- dnorm(xfit) 
lines(xfit, yfit)
```

```{r televote-normality-tests-qqplot, echo = FALSE, warning = FALSE, results = 'hide'}
# QQ-plot of the data
qqPlot(my_model_tele, ylab = "Standardised Residuals", main = "QQ-Plot of Televote Model Standardised Residuals")
```

Non-Constant Error Variance Test

* Ho: constant error variance
* Ha: Non-constant error Variance

```{r televote-nonconstant-variance, echo = FALSE, warning = FALSE}
# Non-Constant Error Variance Test
ncv_test(my_model_tele)
```

```{r televote-nonconstant-variance-spreadlevelplot, echo = FALSE, warning = FALSE, results = 'hide'}
# plot studentized residuals vs. fitted values 
spreadLevelPlot(my_model_tele, main = "Spread-Level Plot for Televote Model")
```

```{r televote-vifs, echo = FALSE, warning = FALSE}
# Variance Inflation Factors 
model_vifs(my_model_tele)
# No signs of collinearity
```

\newpage

## Jury Model

```{r jury-model, echo = FALSE, warning = FALSE}
# load final televote model
my_model_jury <- readRDS("./models/jury_final_model.RDS")
# extract out the model coefficients
jury_model_coeff <- names(my_model_jury$coefficients)[-1]
# recreate the model formula
jury_final_model_form<- as.formula(paste('Points ~', paste(jury_model_coeff, collapse = ' + ')))
# generate model summary
summary(my_model_jury)
```

### Transformation of Response Variable

```{r jury-power-trans, echo = FALSE, warning = FALSE}
# transform points using the optimal power transformation
ptPoints <- jury_data$Points^(3/4)
# Note: weird bug occuring for row name 177 / row index 88 (possibly due to column with near all zero values)
jury_coeff_data <- jury_data %>% subset(select = jury_model_coeff)
jury_coeff_zero_prop <- apply(X = jury_coeff_data, MARGIN = 2, FUN = function(x) sum(x == 0)/length(x)*100)
jury_model_coeff <- names(which(jury_coeff_zero_prop < 99))
# recreate the model formula
jury_final_model_pt_form <- as.formula(paste('ptPoints ~', paste(jury_model_coeff, collapse = ' + ')))
# refit final model with power transformation of 3/4
# NOTE: a box cox transformation resulted in normality but also non-constant variance
my_model_jury <- lm(formula = jury_final_model_pt_form, data = jury_data)
# generate model summary
summary(my_model_jury)
```

### Evaluate the Fit of the Model

```{r jury-standardised-residuals, echo = FALSE, warning = FALSE}
# generate standardised residuals
sresid <- studres(my_model_jury)
# plot residuals vs fits model
plot_residuals_vs_fits(model = my_model_jury, main = "Jury Model - Standardised Residuals vs Fitted Values", output_fpath = './report/plots/residual/model_jury_residuals_vs_fits.jpg')
```

![Jury Model Standardised Residuals vs Fits](../report/plots/residual/model_jury_residuals_vs_fits.jpg)\newline

```{r jury-outliers, echo = FALSE, warning = FALSE}
# Assessing Outliers
# Bonferonni p-value for most extreme obs
bonferroni_outlier_test(my_model_jury)
# print example outliers
head(sresid_outliers(sresid, cutoff = -2))
# leverage plots
leveragePlots(my_model_jury, ask = FALSE) 
# Added variable Plots
avPlots(my_model_jury, ask = FALSE)
# Cook's D plot
plot_cooks(model = my_model_jury, data = processed_data, output_fpath = './report/plots/residual/model_jury_cooks.jpg')
```

![Jury Model Cooks Distance](../report/plots/residual/model_jury_cooks.jpg)\newline

```{r jury-outliers-plots, echo = FALSE, warning = FALSE, results = 'hide'}
# Residual Plots
residualPlots(my_model_jury)
# Influence Plot 
influencePlot(my_model_jury, id.method = "identify", main = "Influence Plot", sub = "Circle size is proportial to Cook's Distance" )
```

Normality Test

* Ho: The data is normally distributed
* Ha: the data is not normally distributed

```{r jury-normality-tests, echo = FALSE, warning = FALSE}
# Normality Test
normality_tests(sresid)
# the data is not normally distributed
# Histogram of residuals
hist(sresid, freq = FALSE, main = "Distribution of Studentised Residuals", ylim = c(0, 0.4))
xfit <- seq(min(sresid, na.rm = TRUE), max(sresid, na.rm = TRUE), length = 40) 
yfit <- dnorm(xfit) 
lines(xfit, yfit)
```

```{r jury-normality-tests-qqplot, echo = FALSE, warning = FALSE, results = 'hide'}
# QQ-plot of the data
qqPlot(my_model_jury, ylab = "Standardised Residuals", main = "QQ-Plot of Jury Vote Model Standardised Residuals")
```

Non-Constant Error Variance Test

* Ho: constant error variance
* Ha: Non-constant error Variance

```{r jury-nonconstant-variance, echo = FALSE, warning = FALSE}
# Non-Constant Error Variance Test
ncv_test(my_model_jury)
```

```{r jury-nonconstant-variance-spreadlevelplot, echo = FALSE, warning = FALSE, results = 'hide'}
# plot studentized residuals vs. fitted values 
spreadLevelPlot(my_model_jury, main = "Spread-Level Plot for Jury Vote Model")
```

```{r jury-vifs, echo = FALSE, warning = FALSE}
# Variance Inflation Factors 
model_vifs(my_model_jury)
# No signs of collinearity
```
