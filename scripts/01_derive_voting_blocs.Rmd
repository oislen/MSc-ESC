---
title: "Derviving Voting Blocs"
output: 
  pdf_document:
    toc: true
    toc_depth: 3
    df_print: kable
---

## Overview

This rmarkdown file generates voting blocs for the Eurovision Song Contest (ESC) using historical voting data. Network analysis is used to generate the voting blocs, and the resulting categorical voting bloc information is used as independent variables to explain contest scores. The presence of Voting blocs within the ESC has been noted by both commentators during the contest and academics. 

```{r preliminaries, message = FALSE, echo = FALSE}
# Load in relevant libraries
library(rmarkdown)
library(knitr)
library(igraph)
library(dplyr)

# load in custom utility functions
source("./scripts/utilities/graph_network.R")

# load in the historic voting data for deriving the voting blocs
past_voting_data <- read.csv(file = "./data/ESC_hist_voting_data.csv", header = T)
```

## Data Profiling / Preparation

The historical voting data records the number of points given from one country to another across the various years of the ESC. The historical voting data is further subdivided by round, either semi-final or final, and by voting method, either jury or televote.

```{r data-profiling, echo = FALSE}
# get the head of the data
head(past_voting_data)
```

### Average Points Dataframe

The historical voting data between all 'from country' and 'to country' combinations are aggregated across the years and the average number of points is calculated.

```{r average-vote-matrix, message = FALSE, echo = FALSE}
# Average over the voting data
pvd <- past_voting_data %>% 
       select(From.country, To.country, Points) %>%
       group_by(From.country, To.country) %>%
       summarise(Average.Points = mean(Points)) %>%
       as.data.frame()

# show head of data
head(pvd)

# write the average voting data to a csv file
write.csv(x = pvd, file = "./data/average_points.csv", row.names = F)
```

### Average Points Graph

The aggregated historical voting data is further filtered to return cases where the average number of distributed points is greater than 8.

```{r average-point-graph, echo = FALSE, results='hide'}
# graph the data based on the weight of the average point score
# assumption: an average point score of 8 or more is a sign of bloc voting
G <- graph_from_data_frame(d = pvd[pvd$Average.Points >= 8, 1:2], directed = T)
E(G)$weight <- as.numeric(pvd[pvd$Average.Points >= 8, 3])
# check the graph is weighted
if (is_weighted(G) == FALSE){
  stop("Voting Network Graph is Unweighted.")
}
# plot the average points graph
graph_network(dataset = pvd, from.country = 'From.country', to.country = "To.country", weights = 'Average.Points')
```

## Voting Blocs

The two network clustering algorithms used are edge betweenness clustering, and short random walks. The connectedness of the clusters / communities are evaluated using modularity. The modularity of a graph with respect to some division (or vertex types) measures how good the grouping is. The higher the modularity the greater the division between communities and the better grouping

### Edge Betweenness Clustering

```{r edge-between-clustering, warning = FALSE, echo = FALSE}
# Perform Edge between clustering
com1 <- cluster_edge_betweenness(graph = G, weights = E(G)$weight)
# create a data frame out of the clustering results
com1df <- as.data.frame(cbind(com1$names, com1$membership))
colnames(com1df) <- c("Country", "Group")
```

Edge betweenness clustering works by iteratively removing edges with the highest edge betweeness score from the graph until no edges remain. This results in a dendrogram between when points when the graph is a single component and when the graph is fully disconnected. The number of clusters generated by edge betweenness is `r max(com1$membership)`. The modularity for the edge betweenness clusters is `r modularity(com1)`.

```{r edge-between-clustering-results, echo = FALSE}
# construct a dendrogram (hierarchical clustering method)
plot_dendrogram(com1, main = "Dendrogram of EDge Betweenness Clustering")
```

### Short Random Walks

```{r short-random-walks, echo = FALSE}
# perform short random walks clustering
com2 <- cluster_walktrap(graph = G, weights = E(G)$weight)
# create a data frame out of the clustering results
com2df <- as.data.frame(cbind(com2$names, com2$membership))
colnames(com2df) <- c("Country", "Group")
```

Short random walks clustering works by performing short random walks between nodes in a graph. Vertices within common communities will tend to occur together more frequently during the short random walks. The number of clusters generated by short random walks is `r max(com2$membership)`. The modularity for the short random walks clusters is `r modularity(com2)`.

```{r short-random-walks-results, echo = FALSE}
# construct a dendrogram (hierarchical clustering method)
plot_dendrogram(com2, main = "Dendrogram of Short Random Walk Clustering")
```

### Combined Voting Blocs

```{r voting-blocks-dataframe, echo = FALSE}
# combine results over both clustering methods into a data frame
voting_bloc_data <- as.data.frame(cbind(com1$names, com1$membership, com2$membership))
# assign column names to the output data frame
colnames(voting_bloc_data) <- c("Country", "VBlocs1_EB", "VBlocs2_SRW")
# results
voting_bloc_data
# Writing Voting Bloc Data to csv file
write.csv(x = voting_bloc_data, file = "./data/voting_bloc_data.csv", row.names = F)
```